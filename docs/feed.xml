<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-10T09:51:44+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Marin Lauber</title><subtitle>Marin Lauber</subtitle><author><name>Marin Lauber</name><email>M.Lauber@tudelft.nl</email></author><entry><title type="html">Lagrangian Coherent Structures: Finite-Time Lyapunov Exponent</title><link href="http://localhost:4000/Finite-Time-Lyapunov-Exponent/" rel="alternate" type="text/html" title="Lagrangian Coherent Structures: Finite-Time Lyapunov Exponent" /><published>2021-11-12T00:00:00+01:00</published><updated>2021-11-12T00:00:00+01:00</updated><id>http://localhost:4000/Finite-Time-Lyapunov-Exponent</id><content type="html" xml:base="http://localhost:4000/Finite-Time-Lyapunov-Exponent/"><![CDATA[<p>Computing FTLE fields with Julia</p>

<h2 id="introduction">Introduction</h2>

<p>In the study of dynamical systems, Lagrangian Coherent Structures (LCS) are an essential tool to distinguish material surface formed by trajectories that exert a consistent action on nearby trajectories. A classical example of an attracting material surface in dynamical system is called an attractor, see the <a href="https://en.wikipedia.org/wiki/Lorenz_system">Lorenz System</a> for example.</p>

<p>One big advantage of using LCS (or in other words tracking particles trajectories) to analyse dynamical systems is their Galilean invariance, unlike Eulerian criteria.</p>

<p>A common way of determining these LCS is trough ridges of the Finite-time Lyapunov (FTLE). In the following, I will detail how this ridges are computed based on numerical results of a simple flow field.</p>

<h2 id="double-gyre-flow">Double-Gyre flow</h2>

<p>The periodically varying double-gyre flow was discussed in <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.120.439&amp;rep=rep1&amp;type=pdf">Shadden et al. (2005)</a>. It is used as a standard test case for LCS and can be considered a local view of a gulf stream ocean front. It is described by the stream-function</p>

\[\psi(x, y, t) = A\sin(\pi f(x, t)) \sin(\pi y)\]

<p>where</p>

\[f(x, t) = \epsilon\sin(\omega t)x^2 + (1-2\epsilon\sin(\omega t))x,\]

<p>the two component of the time-varying velocity field are then found with the definition of the stream-function $\psi = \nabla\times u$ which gives for a 2D case</p>

\[u = -\frac{\partial \psi}{\partial y}, \qquad v = \frac{\partial \psi}{\partial y}.\]

<p>The flow is defined over a domain $L\times H = [0, 2] \times [0, 1]$, see the animation below</p>

<p><img src="/assets/images/flow.gif" alt="double_gyre" /></p>

<h2 id="computation-of-the-ftle">Computation of the FTLE</h2>

<p>To compute FTLE we start with a standard time-dependent velocity field $\vec u \in \mathbb{R}^n \times T$ and a particle trajectory that satisfies</p>

\[\dot{\vec x}(t) = \vec u(\vec x(t), t).\]

<p>In the following example an analytical solution for the time-dependent velocity field $\vec u$ is provided, but it is much more common that this velocity field is obtained from discrete (in time and space) results of numerical simulations, one must therefore use interpolation to find the value of the velocity field between those points.</p>

<p>To compute the FTLE, the approach is to seed the flow with passive particles with location $X_0 \subset \mathbb{R}^n$. The particle’s trajectories are then advected/intergated forward (or backward) in time from the initial time $t-0$ to the final time $t=T$ to obtain the time-T flow-map defined as</p>

\[\Phi_0^T : \mathbb{R}^n \to \mathbb{R}^n; \quad \vec{x}(0) \to \vec x (0) + \int_{0}^{T} \vec u(\vec x(\tau), \tau)\text{ d}\tau.\]

<p><img src="/assets/images/particles.gif" alt="double_gyre_p" /></p>

<p>Once the flow map is obtained, we can compute the deformation gradient tensor ${\bf D}\Phi_0^T$ of every particle, usually by finite-difference (using  the 2D deformation gradient as an example)</p>

\[{\bf D}\Phi_0^T = \begin{bmatrix}
    \frac{\partial X}{\partial x}  &amp;  \frac{\partial X}{\partial y} \\
     \frac{\partial Y}{\partial x} &amp;  \frac{\partial Y}{\partial y} \\
    \end{bmatrix}
    \sim
    \begin{bmatrix}
    \frac{X_{i+1,j}(T) - X_{i-1,j}(T)}{x_{i+1,j}(0) - x_{i-1,j}(0)}  &amp;  \frac{X_{i+1,j}(T) - X_{i-1,j}(T)}{y_{i+1,j}(0) - y_{i-1,j}(0)} \\
    \frac{Y_{i+1,j}(T) - Y_{i-1,j}(T)}{x_{i+1,j}(0) - x_{i-1,j}(0)} &amp;  \frac{Y_{i+1,j}(T) - Y_{i-1,j}(T)}{x_{i+1,j}(0) - x_{i-1,j}(0)} \\
    \end{bmatrix},\]

<p>where $X$ and $x$ are understood to be Lagrangian and Eulerian variables. The finite-difference approximation assumes that we started with a uniform particles distribution. The deformation grandient measures the amount of stretching a particule experienced during the time interval $T$. Next, the Cauchy-Green deformation tensor can be computed</p>

\[{\bf C}_0^T = ({\bf D}\Phi_0^T)^\top{\bf D}\Phi_0^T,\]

<p>where $(.)^\top$ denote the transpose operator. The maximum amount of stretching experienced by the particle is obtained from maximum eigenvalue $\lambda_{\text{max}}$ of the Cauchy-Green deformation tensor. This is equivalent to performing a singular-value decomposition of this tensor. This is then synthesized into a FTLE field for the time-T flow map</p>

\[\sigma(\Phi_0^T; \vec x_0) = \frac{1}{|T|}\log\sqrt{\lambda_{\text{max}}({\bf C}_0^T(\vec x_0))}\]

<blockquote>
  <p><strong><em>Note:</em></strong> This is the procedure to obtain the FTLE of the time-T flow map, this means that these ridges represent attracting/repeling LCS for particles with initial position $t=0$, for a time-varying velociy field, the FTLE field is obtained by numerous integration of these trajectories with the initial condition varying every time, this can be very expansive!</p>
</blockquote>

<h2 id="numerical-implementation-in-julia">Numerical Implementation in <code class="language-plaintext highlighter-rouge">Julia</code></h2>

<p>First, we start by importing the required libraries, here we need the <code class="language-plaintext highlighter-rouge">LinearAlgebra</code> and <code class="language-plaintext highlighter-rouge">PyPlot</code> libraries, off course you can also use another ploting library if you prefer</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">LinearAlgebra</span>
<span class="k">using</span> <span class="n">PyPlot</span>
</code></pre></div></div>

<p>Next we need to define the function <code class="language-plaintext highlighter-rouge">f</code>, the time-varying part of our flow model</p>

\[f(x, t) = \epsilon\sin(\omega t)x^2 + (1-2\epsilon\sin(\omega t))x,\]

<p>which, once transalated to the <code class="language-plaintext highlighter-rouge">Julia</code> language gives</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">t</span><span class="x">,</span> <span class="n">omega</span><span class="x">,</span> <span class="n">epsilon</span><span class="x">)</span>
    <span class="k">return</span> <span class="n">epsilon</span><span class="o">*</span><span class="n">sin</span><span class="x">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="x">)</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="x">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">epsilon</span><span class="o">*</span><span class="n">sin</span><span class="x">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="x">))</span><span class="o">*</span><span class="n">x</span><span class="o">.</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We can then define our stream-function based on this function</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> phi</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">y</span><span class="x">,</span> <span class="n">t</span><span class="x">,</span> <span class="n">A</span><span class="o">=</span><span class="mf">0.1</span><span class="x">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="nb">pi</span><span class="o">/</span><span class="mi">10</span><span class="x">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.2</span><span class="x">)</span>
    <span class="k">return</span> <span class="nd">@.</span> <span class="n">A</span><span class="o">*</span><span class="n">sin</span><span class="x">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">f</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">t</span><span class="x">,</span> <span class="n">omega</span><span class="x">,</span> <span class="n">epsilon</span><span class="x">))</span> <span class="o">*</span> <span class="n">sin</span><span class="x">(</span><span class="nb">pi</span><span class="o">*</span><span class="n">y</span><span class="x">)</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p><strong><em>Note:</em></strong> Note here that we must broadcast the results with <code class="language-plaintext highlighter-rouge">@.</code></p>
</blockquote>

<p>As we will generate a mesh of particle and advect it, we must be able to compute the local flow velocity at any point in space and in time, luckily we do not need to interpolate here, we can just compute the value of the velocity at a given location $\vec r = [x, y]$ using the gradient of the stream-function</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> update</span><span class="x">(</span><span class="n">r</span><span class="x">,</span> <span class="n">t</span><span class="x">,</span> <span class="n">Delta</span><span class="o">=</span><span class="mf">0.0001</span><span class="x">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="x">[</span><span class="o">:</span><span class="x">,</span><span class="mi">1</span><span class="x">];</span> <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="x">[</span><span class="o">:</span><span class="x">,</span><span class="mi">2</span><span class="x">]</span>
    <span class="n">vx</span> <span class="o">=</span> <span class="x">(</span><span class="n">phi</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">y</span><span class="o">.+</span><span class="n">Delta</span><span class="x">,</span><span class="n">t</span><span class="x">)</span><span class="o">.-</span><span class="n">phi</span><span class="x">(</span><span class="n">x</span><span class="x">,</span><span class="n">y</span><span class="o">.-</span><span class="n">Delta</span><span class="x">,</span><span class="n">t</span><span class="x">))</span><span class="o">./</span><span class="x">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Delta</span><span class="x">)</span>
    <span class="n">vy</span> <span class="o">=</span> <span class="x">(</span><span class="n">phi</span><span class="x">(</span><span class="n">x</span><span class="o">.-</span><span class="n">Delta</span><span class="x">,</span><span class="n">y</span><span class="x">,</span><span class="n">t</span><span class="x">)</span><span class="o">.-</span><span class="n">phi</span><span class="x">(</span><span class="n">x</span><span class="o">.+</span><span class="n">Delta</span><span class="x">,</span><span class="n">y</span><span class="x">,</span><span class="n">t</span><span class="x">))</span><span class="o">./</span><span class="x">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Delta</span><span class="x">)</span>
    <span class="k">return</span> <span class="x">[</span><span class="o">-</span><span class="n">vx</span> <span class="o">-</span><span class="n">vy</span><span class="x">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Where we have used a standard central difference to esimate the gradient of the stream-function.</p>

<p>Once we have our particle position at time $T$ (I will detail later how to achieve this) we need to compute the local Cauchy-Green deformation tensor. This could be a complex task, but because we will start with a uniform distribution of particles, neighbouring particles are located at neighbouring indices, which makes things much simpler!</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> Jacobian</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">y</span><span class="x">,</span> <span class="n">delta</span><span class="x">)</span>
    
    <span class="c"># pre-processing</span>
    <span class="n">nx</span><span class="x">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">size</span><span class="x">(</span><span class="n">x</span><span class="x">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="kt">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="nb">undef</span><span class="x">,</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">2</span><span class="x">)</span>
    <span class="n">FTLE</span> <span class="o">=</span> <span class="kt">Array</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}(</span><span class="nb">undef</span><span class="x">,</span> <span class="n">nx</span><span class="o">-</span><span class="mi">2</span><span class="x">,</span> <span class="n">ny</span><span class="o">-</span><span class="mi">2</span><span class="x">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="n">∈</span> <span class="mi">1</span><span class="o">:</span><span class="n">ny</span><span class="o">-</span><span class="mi">2</span><span class="x">,</span> <span class="n">i</span> <span class="n">∈</span> <span class="mi">1</span><span class="o">:</span><span class="n">nx</span><span class="o">-</span><span class="mi">2</span>
        
        <span class="c"># jacobian of that particle</span>
        <span class="n">J</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span> <span class="o">=</span> <span class="x">(</span><span class="n">x</span><span class="x">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="x">,</span><span class="n">j</span><span class="x">]</span><span class="o">-</span><span class="n">x</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">])</span><span class="o">/</span><span class="x">(</span><span class="mi">2</span><span class="o">*</span><span class="n">delta</span><span class="x">)</span>
        <span class="n">J</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">2</span><span class="x">]</span> <span class="o">=</span> <span class="x">(</span><span class="n">x</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="x">]</span><span class="o">-</span><span class="n">x</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">])</span><span class="o">/</span><span class="x">(</span><span class="mi">2</span><span class="o">*</span><span class="n">delta</span><span class="x">)</span>
        <span class="n">J</span><span class="x">[</span><span class="mi">2</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span> <span class="o">=</span> <span class="x">(</span><span class="n">y</span><span class="x">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="x">,</span><span class="n">j</span><span class="x">]</span><span class="o">-</span><span class="n">y</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">])</span><span class="o">/</span><span class="x">(</span><span class="mi">2</span><span class="o">*</span><span class="n">delta</span><span class="x">)</span>
        <span class="n">J</span><span class="x">[</span><span class="mi">2</span><span class="x">,</span><span class="mi">2</span><span class="x">]</span> <span class="o">=</span> <span class="x">(</span><span class="n">y</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="x">]</span><span class="o">-</span><span class="n">y</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">])</span><span class="o">/</span><span class="x">(</span><span class="mi">2</span><span class="o">*</span><span class="n">delta</span><span class="x">)</span>

        <span class="c"># Green-Cauchy tensor</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">transpose</span><span class="x">(</span><span class="n">J</span><span class="x">)</span><span class="o">.*</span><span class="n">J</span>
        
        <span class="c"># its largest eigenvalue</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="n">eigvals</span><span class="x">(</span><span class="n">D</span><span class="x">)</span>
        <span class="n">FTLE</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">]</span> <span class="o">=</span> <span class="n">maximum</span><span class="x">(</span><span class="n">lamda</span><span class="x">)</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">FTLE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Alright, now we can start to look at advecting the particle to find their final position. We will use a $4^{th}$-order <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta method</a> to integrate the equation</p>

\[\dot{\vec x}(t) = \vec u(\vec x(t), t) \sim f(\vec x(t), t)\]

<p>from time $t_n$ to $t_{n+1} = t_n + \Delta t$ following</p>

\[\begin{split}
    k_1 &amp;= \Delta t \, f(\vec r_n, t_n)\\
    k_2 &amp;= \Delta t \, f(\vec r_n + 0.5k_1, t_n+0.5\Delta t)\\
    k_3 &amp;= \Delta t \, f(\vec r_n + 0.5k_2, t_n+0.5\Delta t)\\
    k_4 &amp;= \Delta t \, f(\vec r_n + k_3, t_n+\Delta t)\\
    \vec{r}_{n+1} &amp;= (k_1 + 2k_2 + 2k_3 + k_4 ) / 6.
\end{split}\]

<p>We also need to define a grid of particles to advect. Because the edges of the domain have zero velocity, the particles there won’t move so we won’t bother putting particles on the boundary itself</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># number of positions</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">256</span>

<span class="c"># particle position (2D grid)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">collect</span><span class="x">(</span><span class="kt">LinRange</span><span class="x">(</span><span class="mf">0.01</span><span class="x">,</span> <span class="mf">1.99</span><span class="x">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="x">))</span><span class="err">'</span> <span class="o">.*</span> <span class="n">ones</span><span class="x">(</span><span class="n">N</span><span class="x">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">collect</span><span class="x">(</span><span class="kt">LinRange</span><span class="x">(</span><span class="mf">0.01</span><span class="x">,</span> <span class="mf">0.99</span><span class="x">,</span>   <span class="n">N</span><span class="x">))</span>  <span class="o">.*</span> <span class="n">ones</span><span class="x">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="x">)</span><span class="err">'</span><span class="x">;</span>

<span class="c"># particle positions</span>
<span class="n">r</span> <span class="o">=</span> <span class="x">[</span><span class="n">vec</span><span class="x">(</span><span class="n">x</span><span class="x">)</span> <span class="n">vec</span><span class="x">(</span><span class="n">y</span><span class="x">)]</span>
</code></pre></div></div>

<p>Then we can proceed to intergate in time to find the first flow map $\Phi_{0}^{T}$</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># time step</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">collect</span><span class="x">(</span><span class="n">range</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="mi">20</span><span class="x">,</span> <span class="n">step</span><span class="o">=</span><span class="n">dt</span><span class="x">))</span>

<span class="c"># intergate in time with RK4</span>
<span class="k">for</span> <span class="n">t</span> <span class="n">∈</span> <span class="n">T</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">update</span><span class="x">(</span><span class="n">r</span><span class="x">,</span> <span class="n">t</span><span class="x">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">update</span><span class="x">(</span><span class="n">r</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k1</span><span class="x">,</span> <span class="n">t</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="x">)</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">update</span><span class="x">(</span><span class="n">r</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">k2</span><span class="x">,</span> <span class="n">t</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="x">)</span>
    <span class="n">k4</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">update</span><span class="x">(</span><span class="n">r</span><span class="o">+</span><span class="n">k3</span><span class="x">,</span> <span class="n">t</span><span class="o">+</span><span class="n">dt</span><span class="x">)</span>
    <span class="n">r</span> <span class="o">+=</span> <span class="x">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="x">)</span> <span class="o">/</span> <span class="mi">6</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The resulting advection of a uniform aprticle grid is shown below, the particles are colored with the instantaneous FTLE values</p>

<p><img src="/assets/images/flow_map.gif" alt="flow_map" /></p>

<p>Once we have integrated this flow map, we can extract the $x$ and $y$ coordinates of each points and compute the FTLE using our <code class="language-plaintext highlighter-rouge">Jacobian</code> function</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># extract position</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">reshape</span><span class="x">(</span><span class="n">r</span><span class="x">[</span><span class="o">:</span><span class="x">,</span><span class="mi">1</span><span class="x">],</span> <span class="n">N</span><span class="x">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="x">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">reshape</span><span class="x">(</span><span class="n">r</span><span class="x">[</span><span class="o">:</span><span class="x">,</span><span class="mi">2</span><span class="x">],</span> <span class="n">N</span><span class="x">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="x">);</span>

<span class="c"># compute FTLE</span>
<span class="n">FTLE</span> <span class="o">=</span> <span class="n">Jacobian</span><span class="x">(</span><span class="n">x</span><span class="x">,</span> <span class="n">y</span><span class="x">,</span> <span class="n">r</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">2</span><span class="x">]</span><span class="o">-</span><span class="n">r</span><span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">1</span><span class="x">])</span>
<span class="n">FTLE</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="x">(</span><span class="n">FTLE</span><span class="x">);</span>
</code></pre></div></div>

<p>We can the proceed to plot the results</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contour</span><span class="x">(</span><span class="n">FTLE</span><span class="x">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">31</span><span class="x">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">"viridis"</span><span class="x">)</span>
</code></pre></div></div>

<p>Because the flow is time-dependent, we must perform this integartion for every time-step. This means re-generating the array of particle, but now at time $t=\Delta t$, such that we now obtain the flow map $\Phi_{\Delta t}^{T+\Delta t}$, and so on.</p>

<p>Once this is done we can assemble the time-varying FTLE field of the double-gyre flow</p>

<p><img src="/assets/images/Lyapunov.gif" alt="FTLE_double_gyre" /></p>

<p>Areas of high sretching are represented by the sharp green ridges, particules that started at this location experienced a larger stretching than particles that started from bluer regions.</p>

<p>We can notice that because the base flow is periodic, our FTLE field is also periodic.</p>

<h2 id="inspiration">Inspiration</h2>

<p><a href="https://www.youtube.com/watch?v=lveOu7jLNh0">Steve Brunton’s brillant video!</a></p>

<hr />]]></content><author><name>Marin Lauber</name><email>M.Lauber@tudelft.nl</email></author><summary type="html"><![CDATA[Computing FTLE fields with Julia]]></summary></entry><entry><title type="html">Advanced Scientific Matplotlib - Part 1/n</title><link href="http://localhost:4000/Avdanced-Matplotlib-1/" rel="alternate" type="text/html" title="Advanced Scientific Matplotlib - Part 1/n" /><published>2021-07-05T00:00:00+02:00</published><updated>2021-07-05T00:00:00+02:00</updated><id>http://localhost:4000/Avdanced-Matplotlib-1</id><content type="html" xml:base="http://localhost:4000/Avdanced-Matplotlib-1/"><![CDATA[<p>This series of blog post is here to give some of the tricks I use to produce high-quality figures, suitable for publications.</p>

<h2 id="introduction">Introduction</h2>

<p>Of course I am using <code class="language-plaintext highlighter-rouge">matplotlib</code> to create all sorts of figures and animations! Coupled with <code class="language-plaintext highlighter-rouge">numpy</code> and somethimes <code class="language-plaintext highlighter-rouge">pandas</code> to read and handle all sorts of data, these are some very powerful tools. I am not going to cover the basics of matplotlib, such as importing the library, or doing simple plots. There have been lots of excellent examples on the subjects already.</p>

<p>Instead I will dig a bit deeper in what <code class="language-plaintext highlighter-rouge">matplotlib</code> has to offer and how we can benefit from it to show the results of our research.</p>

<h2 id="using-style-sheets">Using Style Sheets</h2>

<p>Custom style-sheets are a very efficient way to improve the default plotting style from matplotlib. You can get some excellent one from <a href="https://github.com/garrettj403/SciencePlots">here</a>. Once they are installed in the correct directory, you can simply use them with</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">use</span><span class="p">.</span><span class="nf">style</span><span class="p">(</span><span class="s">"my_amazing_style"</span><span class="p">)</span>
</code></pre></div></div>

<p>The style-sheets are save in a <code class="language-plaintext highlighter-rouge">.mplstyle</code> format. Here is an axample from a basic style sheet</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Matplotlib style for general scientific plots</span>

<span class="c"># Set color cycle</span>
axes.prop_cycle : cycler<span class="o">(</span><span class="s1">'color'</span>, <span class="o">[</span><span class="s1">'0C5DA5'</span>, <span class="s1">'00B945'</span>, <span class="s1">'FF9500'</span>, <span class="s1">'FF2C00'</span>, <span class="s1">'845B97'</span>, <span class="s1">'474747'</span>, <span class="s1">'9e9e9e'</span><span class="o">])</span>

<span class="c"># Set default figure size</span>
figure.figsize : 3.5, 2.625

<span class="c"># Set x axis</span>
xtick.direction : <span class="k">in
</span>xtick.major.size : 3
xtick.major.width : 0.5
xtick.minor.size : 1.5
xtick.minor.width : 0.5
xtick.minor.visible :   True
xtick.top : True

<span class="c"># Set y axis</span>
ytick.direction : <span class="k">in
</span>ytick.major.size : 3
ytick.major.width : 0.5
ytick.minor.size : 1.5
ytick.minor.width : 0.5
ytick.minor.visible :   True
ytick.right : True

<span class="c"># Set line widths</span>
axes.linewidth : 0.5
grid.linewidth : 0.5
lines.linewidth : 1.

<span class="c"># Remove legend frame</span>
legend.frameon : False

<span class="c"># Always save as 'tight'</span>
savefig.bbox : tight
savefig.pad_inches : 0.05

<span class="c"># Use serif fonts</span>
font.serif : Times New Roman
font.family : serif

<span class="c"># Use LaTeX for math formatting</span>
text.usetex : True
text.latex.preamble : <span class="se">\u</span>sepackage<span class="o">{</span>amsmath<span class="o">}</span>
</code></pre></div></div>

<center>
<img src="/assets/images/figure_0.png" alt="" pading="1px" style="width:1200" />
</center>

<p>There are a few interesting things to note, first, we have changed the default plotting colors. We have also enabled <code class="language-plaintext highlighter-rouge">LaTeX</code> to be used for the labels.</p>

<p>We also changed the direction on the tickmarks on the axis.</p>

<blockquote>
  <p><strong><em>Note:</em></strong>  Under <code class="language-plaintext highlighter-rouge">OSX</code> the directory that stores your stylsheets is located at <code class="language-plaintext highlighter-rouge">.matplotlib/stylelib/</code> and in Linux (Ubuntu 18.04) under <code class="language-plaintext highlighter-rouge">.config/matplotlib/stylelib/</code>.</p>
</blockquote>

<p>and yes, we have plotted a figure with two axes, and the axes have different style, simply like this</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">()</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="nf">add_gridspec</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax1</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="nf">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="p">...</span> <span class="c1"># plot what you want
</span><span class="n">plt</span><span class="p">.</span><span class="n">style</span><span class="p">.</span><span class="nf">use</span><span class="p">(</span><span class="s">"new_style"</span><span class="p">)</span>
<span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="nf">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">sharey</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>
<span class="p">...</span> <span class="c1"># plot what you want
</span></code></pre></div></div>]]></content><author><name>Marin Lauber</name><email>M.Lauber@tudelft.nl</email></author><summary type="html"><![CDATA[This series of blog post is here to give some of the tricks I use to produce high-quality figures, suitable for publications.]]></summary></entry><entry><title type="html">Compact Schemes for the Poisson Equation</title><link href="http://localhost:4000/Compact-Poisson-Equation/" rel="alternate" type="text/html" title="Compact Schemes for the Poisson Equation" /><published>2020-12-15T00:00:00+01:00</published><updated>2020-12-15T00:00:00+01:00</updated><id>http://localhost:4000/Compact-Poisson-Equation</id><content type="html" xml:base="http://localhost:4000/Compact-Poisson-Equation/"><![CDATA[<p>If you prefer to follow in the notebook directly, you can also <a href="/notebooks/Compact-Schemes-for-Poisson-Equation.ipynb">get the notebook</a>.</p>

<h3 id="introduction">Introduction</h3>

<p>Finite differnce schemes can be derived from a taylor series expansion up to very large <a href="https://en.wikipedia.org/wiki/Finite_difference_coefficient">accuracy</a>. The idea is to gain accuracy by increasing the number of points in the stencil. This works well, but can be cumbersome computationally as the stencils become very large and the modifications to the stencil that are required at the boundaries to maintain a uniform global accuracy are complex. This is where compact schemes become an interesting alternative.</p>

<hr />

<h3 id="compact-nth-order-derivative">Compact n$^{th}$-order derivative</h3>

<p>Compact schemes are derived using a Taylor series expansion. Say we wish to construct a compact scheme with a three-point stencil using the value of the function at $x_{i-1}$, $x_i$ and $x_{i+1}$. If we used standard central difference schemes, this will only results in a 2$^{nd}$-order accurate approximation of \(f'(x_i)\). In compact schemes, we not increase the order of accuracy by inclding neighbouring points of the unkown function derivative on the left-hand-side.</p>

<p>For the n$^{th}$ derivative we have the following system</p>

\[L_{i-1}f^{(n)}_{i-1} + L_{i}f^{(n)}_{i} + L_{i+1}f^{(n)}_{i+1} = R_{i-1}f_{i-1} + R_{i}f_{i} + R_{i+1}f_{i+1},\]

<p>where $L_j$ and $R_j$ are unkown coefficients. They are found by solving the linear system</p>

\[\begin{bmatrix}
    \begin{matrix}
        0 &amp; 0 &amp; 0
    \end{matrix} &amp; \begin{matrix}
        1 &amp; 1 &amp; 1\\
    \end{matrix}\\
    Q^{(n)} &amp; \begin{matrix}
h_{i-1} &amp; 0 &amp; h_{i+1}\\
h_{i-1}^2/2! &amp; 0 &amp; h_{i+1}^2/2!\\
h_{i-1}^3/3! &amp; 0 &amp; h_{i+1}^3/3!\\
h_{i-1}^4/4! &amp; 0 &amp; h_{i+1}^4/4!
\end{matrix}\\
\begin{matrix}
        0 &amp; 1 &amp; 0
    \end{matrix} &amp; \begin{matrix}
        0 &amp; 0 &amp; 0\\
    \end{matrix}\\
\end{bmatrix}\begin{bmatrix}
L_{i-1} \\ L_{i} \\ L_{i+1} \\ -R_{i-1} \\ -R_{i} \\ -R_{i+1}\\
\end{bmatrix}=\begin{bmatrix}
0\\ 0\\ 0\\ 0\\ 0\\ 1\\
\end{bmatrix},\]

<p>where $h_{i-1}=x_{i-1}-x_i$ and $h_{i+1} = x_{i+1}-x_i$. The sub-matrix $Q^{(n)}$ depends on the derivative required. For the first derivative, we have</p>

\[Q^{(1)} = \begin{bmatrix}
1 &amp; 1 &amp; 1\\
h_{i-1} &amp; 0 &amp; h_{i+1}\\
h_{i-1}^2/2! &amp; 0 &amp; h_{i+1}^2/2!\\
h_{i-1}^3/3! &amp; 0 &amp; h_{i+1}^3/3!\\
\end{bmatrix}\]

<p>and for the second derivative</p>

\[Q^{(2)} = \begin{bmatrix}
0 &amp; 0 &amp; 0\\
1 &amp; 1 &amp; 1\\
h_{i-1} &amp; 0 &amp; h_{i+1}\\
h_{i-1}^2/2! &amp; 0 &amp; h_{i+1}^2/2!\\
\end{bmatrix}.\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_compact_coeffs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span>
    <span class="c1"># assumes uniform grid
</span>    <span class="n">h_i</span> <span class="o">=</span> <span class="o">-</span><span class="n">hi</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">((</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]),</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hi</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h_i</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h_i</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hi</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h_i</span><span class="o">**</span><span class="mi">4</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hi</span><span class="o">**</span><span class="mi">4</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">4</span><span class="p">)],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">insert</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span>           <span class="mi">1</span><span class="p">,</span>                <span class="mi">1</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">h_i</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>               <span class="n">hi</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">h_i</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span>
                       <span class="p">[</span><span class="n">h_i</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hi</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="nf">fact</span><span class="p">(</span><span class="mi">3</span><span class="p">)]])</span>
    <span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="mi">5</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">insert</span><span class="p">[:</span><span class="o">-</span><span class="n">n</span><span class="o">+</span><span class="mi">5</span><span class="p">,:]</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vec</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="o">-</span><span class="n">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
</code></pre></div></div>

<p>We can check that for a first derivative, we recover the standard Pade ($4^{th}$-order) <a href="https://github.com/marinlauber/my-numerical-recipes/blob/master/Compact-Schemes.ipynb">coefficients</a>, which are</p>

\[L = \left[\frac{1}{4}, 1, \frac{1}{4}\right], \qquad R = \left[-\frac{3}{4}, 0., \frac{3}{4}\right]\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pade</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="o">/</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">3.</span><span class="o">/</span><span class="mf">4.</span><span class="p">])</span>
<span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">hstack</span><span class="p">(</span><span class="nf">get_compact_coeffs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">pade</span><span class="p">)</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
</code></pre></div></div>
<p>We can now write a function that, given a function $f$, on a uniform grid with spacing $dx$, return the $n^{th}$ derivative of that function. Because for each point we solve for the compact coefficients, we can in theory get compact schemes on non-uniform grid with the same accuracy. Here we will only focus on uniform grids.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">derive_compact</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
    
    <span class="c1"># get coeffs
</span>    <span class="n">L</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nf">get_compact_coeffs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
    
    <span class="c1"># temp array
</span>    <span class="n">sol</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">empty_like</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    <span class="c1"># compact scheme on interior points
</span>    <span class="n">sol</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># boundary points
</span>    <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sol</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">sol</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">[</span> <span class="mi">2</span><span class="p">]</span>
    
    <span class="c1"># build ugly matrix by hand
</span>    <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">.</span><span class="nf">diags</span><span class="p">(</span><span class="n">L</span><span class="p">,[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">f</span><span class="p">),</span><span class="nf">len</span><span class="p">(</span><span class="n">f</span><span class="p">))).</span><span class="nf">toarray</span><span class="p">()</span>
    <span class="c1"># periodic BS's
</span>    <span class="n">A</span><span class="p">[</span> <span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
</code></pre></div></div>

<p>We can then test the method on a known function, with known first and second derivaive. For simplicity, we will use trigonometric functions, which have an infinite number of well-behaved derivatives</p>

\[f(x) = \sin(x), \,\, x\in[0, 2\pi).\]

<p>With</p>

\[\frac{d}{dx}f(x) = \cos(x), \quad \frac{d^2}{dx^2}f(x) = -\sin(x), \,\, x\in[0, 2\pi).\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">x</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">function</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># first derivative
</span><span class="n">sol</span> <span class="o">=</span> <span class="nf">derive_compact</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">'First derivative L2 norm:  '</span><span class="p">,</span> <span class="nf">norm</span><span class="p">(</span><span class="n">sol</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

<span class="c1"># second derivative
</span><span class="n">sol</span> <span class="o">=</span> <span class="nf">derive_compact</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">'Second derivative L2 norm: '</span><span class="p">,</span> <span class="nf">norm</span><span class="p">(</span><span class="n">sol</span><span class="o">+</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>First derivative L2 norm:   2.00356231982653e-09
Second derivative L2 norm:  1.5119843767976088e-09
</code></pre></div></div>

<hr />

<h3 id="poisson-equation-with-compact-schemes">Poisson Equation With Compact Schemes</h3>

<p>We aim to solve the following one-dimensionnal Poisson equation with Dirichlet boundary conditions</p>

\[\begin{split}
    -&amp;\frac{d^2}{dx^2}u(x) = f(x), \quad a&lt;x&lt;b\\
    &amp;u(a) = 0, \quad u(b) = 0\\
\end{split}\]

<p>where $a, b\in\mathbb{R}$, $u(x)$ is the unkown function and $f(x)$ is some given source term.</p>

<p>The approach that we will use here is different, in this case, we know the value of the derivatie of the function $u$, they are equal to the source term. We want to re-write our Poisson equation in terms of the unkown function $u$ (and not it’s derivative \(u'\)) as a function of $f$. To do so, we discretize the left side of the Poisson equation (\(u''_i\)) using a compact finite difference scheme with fourth-order accuracy on a uniform grid with grid points located at $x_i = a+ih,$  $ h=(b-a)/M,$ with $i=0, 1, 2,…, M$ where $M$ is a positive integer, as we would if the derivatives where the unknown. This gives</p>

\[\frac{1}{10}u''_{i-1} + u''_i + \frac{1}{10}u''_{i+1} = \frac{6}{5}\frac{u_{i+1} + 2u_i + u_{i-1}}{h^2},\]

<p>or in a more common form,</p>

\[u''_{i-1} + 10u''_i + u''_{i+1} = \frac{12}{h^2}\left(u_{i+1} + 2u_i + u_{i-1}\right).\]

<p>Because we are using points $\pm1$ away from $x_i$, this results in a tri-diagonal system</p>

\[AU''= \frac{12}{h^2}BU,\]

<p>where \(U'' = (u''_1,u''_2,...,u''_M)^\top\) and \(U = (u_1,u_2,...,u_M)^\top\in \mathbb{R}^{M-1}\). The tri-diagonal matrix \(A, B \in \mathbb{R}^{M-1\times M-1}\) are</p>

\[A = \begin{bmatrix}
10 &amp; 1 &amp; 0 &amp;\dots &amp; 0 &amp; 0 \\
1 &amp; 10 &amp; 1 &amp;\dots &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 10 &amp;\dots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \dots &amp; 10 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp;\dots &amp; 1 &amp; 10 \\
\end{bmatrix}, \qquad B = \begin{bmatrix}
-2 &amp; 1 &amp; 0 &amp;\dots &amp; 0 &amp; 0 \\
1 &amp; -2 &amp; 1 &amp;\dots &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; -2 &amp;\dots &amp; 0 &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \dots &amp; -2 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp;\dots &amp; 1 &amp; -2 \\
\end{bmatrix}.\]

<p>To find the unkwon values of $U$, we just need to invert the system, but \(U''\) is still unkown! Well actually, it is know from the Poisson problem \(-u''(x_i)=f(x_i), i=1,2,...,M-1\) i.e. \(-U''=F\). Substituting this result in the previous linear system gives</p>

\[-\frac{12}{h^2}BU = AF,\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">build_AB</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">.</span><span class="nf">diags</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">10.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">)).</span><span class="nf">toarray</span><span class="p">()</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">.</span><span class="nf">diags</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">)).</span><span class="nf">toarray</span><span class="p">()</span>
    <span class="c1"># dont forget BC, here homogeneous Dirichlet
</span>    <span class="n">B</span><span class="p">[</span> <span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span> <span class="n">B</span><span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span><span class="mf">0.</span><span class="p">;</span> <span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="mf">12.</span><span class="o">/</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">B</span>
</code></pre></div></div>

<p>To obtaine the solution $U$, we simply need to solve it! The $B$ matrix is symmetric and positively-definite, it is trivial to solve.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">SolvePoissonCompact</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="nf">build_AB</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h4 id="example-1">Example 1.</h4>

<p>In the first example, we consider the problem with homogeneous Dirichlet boundary conditions</p>

\[\begin{cases}
    -u''(x) = \pi^2\sin(\pi x), &amp; 0 &lt; x &lt;2,\\
      u(0)=0, \quad u(2) = 0.
\end{cases}\]

<p>The exact solution is $u_e(x)=\sin(\pi x)$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">x</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="n">u_num</span> <span class="o">=</span>  <span class="nc">SolvePoissonCompact</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">norm</span><span class="p">(</span><span class="n">u_num</span><span class="o">-</span><span class="n">u_e</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">'-s'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_num</span><span class="p">,</span><span class="s">'-o'</span><span class="p">)</span>
</code></pre></div></div>
<p>which gives you</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6.02248257496857e-06
</code></pre></div></div>
<p><img src="/notebooks/figure_1.png" width="800" /></p>

<hr />

<h4 id="example-2">Example 2.</h4>

<p>Now with non-zero Dirichlet Boundry conditions</p>

\[\begin{cases}
    -u''(x) = 12e^{-x^2}(-x^2+1/2), &amp; -8 &lt; x &lt;8,\\
      u(-8)=-8, \quad u(8) = 8.
\end{cases}\]

<p>The exact solution is $u_e(x)=3e^{-x^2}$. In the numerical computation, we make use of a change of variable $U(x)=u(x)-x$ to solve this problem. Applying the numerical algorithm, we now have</p>

\[\begin{cases}
    -U''(x) = 12e^{-x^2}(-x^2+1/2), &amp; -8 &lt; x &lt;8,\\
      U(-8)=-0, \quad U(8) = 0.
\end{cases}\]

<p>and the approximate numerical solution at a grid point is found as $u(x) = U(x)=x$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">M</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">8.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="mf">12.</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="mf">3.</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">x</span>
    <span class="n">u_num</span> <span class="o">=</span> <span class="nc">SolvePoissonCompact</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">norm</span><span class="p">(</span><span class="n">u_num</span><span class="o">-</span><span class="n">u_e</span><span class="p">))</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">'-s'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_num</span><span class="o">+</span><span class="n">x</span><span class="p">,</span><span class="s">'-o'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.5864429590964948
</code></pre></div></div>

<p><img src="/notebooks/figure_2.png" width="800" /></p>

<hr />

<h3 id="using-faste-fourier-transforms-to-solve-the-poisson-equation">Using Faste Fourier Transforms to Solve the Poisson Equation</h3>

<p>We actually do not need ton inverte the system described earlier to get the solution, <a href="https://www.sciencedirect.com/science/article/pii/S0898122116300761">see</a>. We can use the Sine transform for $U\in\mathbb{R}^{M-1}$</p>

\[\begin{split}
    u_j &amp;= \sum_{k=1}^{M-1}\hat{u}_k\sin\left(\frac{jk\pi}{M}\right), \,\, j=1,2,...,M-1,\\
    \hat{u_k} &amp;= \frac{2}{M}\sum_{j=1}^{M-1}u_j\sin\left(\frac{ik\pi}{M}\right), \,\, j=1,2,...,M-1,
\end{split}\]

<p>from whcih we can approximate $u_{i+1}$, $u_{i-1}$, \(u''_{i+1}\), \(u''_{i-1}\) as</p>

\[\begin{align}
   u_{i+1}=\sum_{k=1}^{M-1}\hat{u}_k\sin\left(\frac{(i+1)k\pi}{M}\right),\qquad &amp; u_{i-1} = \sum_{k=1}^{M-1}\hat{u}_k\sin\left(\frac{(i-1)k\pi}{M}\right)\\
   u''_{i} =\sum_{k=1}^{M-1}\hat{u}''_k\sin\left(\frac{ik\pi}{M}\right),\qquad &amp; u''_{i+1} =\sum_{k=1}^{M-1}\hat{u}''_k\sin\left(\frac{(i+1)k\pi}{M}\right)\\
   u''_{i-1} =\sum_{k=1}^{M-1}\hat{u}''_k\sin\left(\frac{(i-1)k\pi}{M}\right). &amp; \\
\end{align}\]

<p>Subsituting in the compact discretization of the Poisson equation gives,</p>

\[\begin{split}
\sum_{k=1}^{M-1}\hat{u}''_k\left\{ \frac{1}{10}\sin\left(\frac{(i-1)k\pi}{M}\right) + \sin\left(\frac{ik\pi}{M}\right) + \frac{1}{10}\sin\left(\frac{(i+1)k\pi}{M}\right) \right\} =\\
\frac{6}{5h^2}\sum_{k=1}^{M-1}\hat{u}_k\left\{ \sin\left(\frac{(i-1)k\pi}{M}\right) +\sin\left(\frac{(i+1)k\pi}{M}\right) - 2\sin\left(\frac{ik\pi}{M}\right) \right\}
\end{split}\]

<p>or, after rearranging</p>

\[\hat{u}_k = -\hat{u}''_k\left(\frac{24\sin^2\left(\frac{k\pi}{2M}\right)}{h^2}\right)^{-1}\left(\cos\left(\frac{k\pi}{M}\right)+5\right), \,\, k\in 1,2,..,M-1.\]

<p>In addition, we obtain \(-u''_{i} = f_i \,(i=1,2,...,M-1)\). By the inverse Sine transform, we get to know \(-\hat{u}''_k=\hat{f}_k \, (k=1,2,...,M-1)\), which allows us to solve for $\hat{u}$</p>

\[\hat{u}_k = \hat{f}_k\left(\frac{24\sin^2\left(\frac{k\pi}{2M}\right)}{h^2}\right)^{-1}\left(\cos\left(\frac{k\pi}{M}\right)+5\right), \,\, k\in 1,2,..,M-1.\]

<blockquote>
  <p><strong><em>Note:</em></strong> We use a spectral method to solve the tri-diagonal system, this doesn’t mean we solve it with spectral accuracy, here the modified wavenumber makes the spectral method the exact same accuracy as the compact scheme.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">SolvePoissonSine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="n">f_k</span> <span class="o">=</span> <span class="n">fftpack</span><span class="p">.</span><span class="nf">dst</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s">'ortho'</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u_k</span> <span class="o">=</span> <span class="n">f_k</span><span class="o">*</span><span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="p">))</span><span class="o">**</span><span class="mf">2.</span><span class="o">/</span><span class="n">h</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="n">M</span><span class="p">)</span><span class="o">+</span><span class="mf">5.</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fftpack</span><span class="p">.</span><span class="nf">idst</span><span class="p">(</span><span class="n">u_k</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s">'ortho'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">x</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="mf">12.</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">u_e</span> <span class="o">=</span> <span class="mf">3.</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">x</span>
<span class="n">u_num</span> <span class="o">=</span> <span class="nc">SolvePoissonSine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">norm</span><span class="p">(</span><span class="n">u_num</span><span class="o">-</span><span class="n">u_e</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_num</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="s">'-o'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">'s'</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.5864429590964948
</code></pre></div></div>

<p><img src="/notebooks/figure_3.png" width="800" /></p>

<hr />

<h3 id="order-of-accuracy">Order of Accuracy</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">L2_com</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">L2_Sine</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">Resolutions</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">**</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">Resolutions</span><span class="p">:</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">retstep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
    <span class="n">u_num</span> <span class="o">=</span> <span class="nc">SolvePoissonCompact</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nf">norm</span><span class="p">(</span><span class="n">u_num</span><span class="o">-</span><span class="n">u_e</span><span class="p">)</span>
    <span class="n">L2_com</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="n">u_num</span> <span class="o">=</span> <span class="nc">SolvePoissonSine</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nf">norm</span><span class="p">(</span><span class="n">u_num</span><span class="o">-</span><span class="n">u_e</span><span class="p">)</span>
    <span class="n">L2_Sine</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">loglog</span><span class="p">(</span><span class="n">Resolutions</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">L2_com</span><span class="p">),</span> <span class="s">'--o'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'Compact Schemes'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">loglog</span><span class="p">(</span><span class="n">Resolutions</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">L2_Sine</span><span class="p">),</span> <span class="s">':s'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'Sine Transform'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">loglog</span><span class="p">(</span><span class="n">Resolutions</span><span class="p">,</span> <span class="n">Resolutions</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="s">':k'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s">"$4^{th}$-order"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="s">"Resolution (N)"</span><span class="p">);</span> <span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s">"$L_2$-norm Error"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/notebooks/figure_4.png" width="800" /></p>]]></content><author><name>Marin Lauber</name><email>M.Lauber@tudelft.nl</email></author><summary type="html"><![CDATA[If you prefer to follow in the notebook directly, you can also get the notebook.]]></summary></entry><entry><title type="html">APS-Division of Fluid Dynamics</title><link href="http://localhost:4000/APS-DFD/" rel="alternate" type="text/html" title="APS-Division of Fluid Dynamics" /><published>2020-11-22T00:00:00+01:00</published><updated>2020-11-22T00:00:00+01:00</updated><id>http://localhost:4000/APS-DFD</id><content type="html" xml:base="http://localhost:4000/APS-DFD/"><![CDATA[<p>Abstract and video of my talk at APS-DFD 2020</p>

<h3 style="margin-top: 30px; margin-bottom: 0px; color:rgba(95,205,252,0.8) ; text-align:center;">73rd Annual Meeting of the APS Division of Fluid Dynamics</h3>

<h1 style="margin-top: 30px; margin-bottom: 0px; text-align:center;">Pressure Treatment in Immersed Boundary Methods</h1>

<h3 style="margin-top: 30px; margin-bottom: 0px; text-align:center;">M.Lauber  and G.D. Weymouth</h3>

<p style="margin-top: 30px; margin-bottom: 0px; color:rgba(0, 0, 0, 0.68); text-align:center;">Maritime Engineering Group, University of Southampton</p>
<p style="margin-top: 30px; margin-bottom: 0px; color:rgba(0, 0, 0, 0.68); text-align:center;">8.3 Computational Fluid Dynamics: Immersed Boundary Methods</p>

<h3>Abstract :</h3>

<p>
Immersed boundary methods are extensively used for fluid-structure interaction problems involving large deformations and complex motion of the body. When the driving force of the flow is the body itself, correctly capturing the pressure forces is extremely important, however, very few immersed boundary methods correctly impose the no-penetration condition which can lead to substantial errors in those forces. 
</p>

<p>
We show by means of numerical simulation of a 3D flapping wings that the correct pressure flux treatment on the immersed boundary must be applied in order to satisfy the no-slip/no-penetration boundary condition on thin immersed bodies. 
</p>

<h3 style="margin-top: 30px; margin-bottom: 0px"> <a href="https://meetings.aps.org/Meeting/DFD20/Session/F12.12" id="Marin-thin-BDIM"> Immersed boundary simulations of thin flexible structures</a></h3>
<iframe width="560" height="315" src="https://www.youtube.com/embed/0hK1I5bEBOM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>]]></content><author><name>Marin Lauber</name><email>M.Lauber@tudelft.nl</email></author><summary type="html"><![CDATA[Abstract and video of my talk at APS-DFD 2020]]></summary></entry><entry><title type="html">Pseudo-spectral method for 2D Turbulence</title><link href="http://localhost:4000/2D-Turbulence/" rel="alternate" type="text/html" title="Pseudo-spectral method for 2D Turbulence" /><published>2020-11-20T00:00:00+01:00</published><updated>2020-11-20T00:00:00+01:00</updated><id>http://localhost:4000/2D-Turbulence</id><content type="html" xml:base="http://localhost:4000/2D-Turbulence/"><![CDATA[<p>Accurate simulation of 2D Turbulence</p>

<h2 id="mathematical-formualtion">Mathematical Formualtion</h2>

<h3 id="vorticity-equation">Vorticity equation</h3>

<p>The vorticity (or <em>Helmholtz’s</em>) equation describes the transport of vorticity. We can obtain it by applying the curl operator to the <em>Navier-Stokes</em> equations</p>

<p><a id="1.1"></a>
\begin{equation}
\nabla \times\left(  \frac{\partial\boldsymbol{u}}{\partial t} + (\boldsymbol{u}\cdot \nabla)\boldsymbol{u} = -\frac{1}{\rho}\nabla p + \nu \nabla^2 \boldsymbol{u}\right),  \tag{1.1}
\end{equation}</p>

<p>where $\boldsymbol{u}$ is the velocity field and $p$ is the pressure field. The convective term can be re-arranged to a more suitable form</p>

<p>\begin{equation}
\boldsymbol{u}\times\left(\nabla\times\boldsymbol{u}\right) + \left(\boldsymbol{u}\cdot\nabla\right)\boldsymbol{u} = \nabla\left(\frac{\boldsymbol{u}^2}{2}\right) \rightarrow  \left(\boldsymbol{u}\cdot\nabla\right)\boldsymbol{u} = \nabla\left(\frac{\boldsymbol{u}^2}{2}\right) + \boldsymbol{\omega}\times\boldsymbol{u},
\end{equation}</p>

<p>using definition of the vorticity ($\boldsymbol{\omega}=\nabla\times\boldsymbol{u}$). Substitution in <a href="#1.1">(1.1)</a> gives</p>

<p>\begin{equation}
\nabla \times\left(  \frac{\partial\boldsymbol{u}}{\partial t} + \nabla\left(\frac{\boldsymbol{u}^2}{2}\right) + \boldsymbol{\omega} \times\boldsymbol{u} = -\frac{1}{\rho}\nabla p + \nu \nabla^2 \boldsymbol{u}\right).
\end{equation}</p>

<p>Distributing the curl operator and making use of the definition of the vorticity, we have</p>

<p>\begin{equation}
\frac{\partial\boldsymbol{\omega}}{\partial t} + \nabla \times\nabla\left(\frac{\boldsymbol{u}^2}{2}\right) + \nabla \times\left(\boldsymbol{\omega} \times\boldsymbol{u}\right) = -\nabla \times\left( \frac{1}{\rho}\nabla p\right) + \nu \nabla^2 \boldsymbol{\omega}.
\end{equation}</p>

<p>The third term can be expanded using the <em>curl of the curl</em> vector identity</p>

<p>\begin{equation}
\frac{\partial\boldsymbol{\omega}}{\partial t} + \nabla \times\nabla\left(\frac{\boldsymbol{u}^2}{2}\right) + \boldsymbol{u}\cdot\nabla\boldsymbol{\omega} - \boldsymbol{u}\nabla\cdot\boldsymbol{\omega} - \boldsymbol{\omega}\cdot\nabla\boldsymbol{u} + \boldsymbol{\omega}\nabla\cdot\boldsymbol{u} = -\nabla \times\left( \frac{1}{\rho}\nabla p\right) + \nu \nabla^2 \boldsymbol{\omega}.
\end{equation}</p>

<p>The fourth term vanishes as $\nabla\cdot\boldsymbol{\omega}\equiv 0$ (the divergence of the curl of a vector field is always zero). For an incompressible flow the sixth term equaly vanishes</p>

<p>\begin{equation}
	\frac{\partial\boldsymbol{\omega}}{\partial t} + \nabla \times\nabla\left(\frac{\boldsymbol{u}^2}{2}\right) + \boldsymbol{u}\cdot\nabla\boldsymbol{\omega} - \boldsymbol{\omega}\cdot\nabla\boldsymbol{u}  = -\nabla \times\left( \frac{1}{\rho}\nabla p\right) + \nu \nabla^2 \boldsymbol{\omega}.
\end{equation}</p>

<p>The second term, which is the <em>curl of a tensor</em>, can be shown to vanish as well. Indeed, the curl of a tensor  $\boldsymbol{S}$ is defined as</p>

<p>\begin{equation}
	(\nabla\times\boldsymbol{S})\cdot\boldsymbol{a} = \nabla\times(\boldsymbol{S}^\top \cdot\boldsymbol{a}) \quad \forall \boldsymbol{a}, 
\end{equation}</p>

<p>where $\boldsymbol{a}$ is a vector. In this case, the tensor $\boldsymbol{S}$ is given by the gradient of a vector field, and as gradient and divergence commute</p>

<p>\begin{equation}
	\left(\nabla \times\nabla\left(\frac{\boldsymbol{u}^2}{2}\right)\right)\cdot\boldsymbol{a} = \nabla\times\left(\nabla^\top\left(\frac{\boldsymbol{u}^2}{2}\right)\cdot\boldsymbol{a}\right) = \nabla\times\left(\nabla\left(\frac{\boldsymbol{u}^2}{2}\cdot\boldsymbol{a}\right)\right) = \nabla\times\nabla\psi\equiv0.
\end{equation}</p>

<p>As the curl of the gradient of a scalar field is always zero. Finally, the pressure term can be expanded using the product rule</p>

<p>\begin{equation}
	\nabla \times\left( \frac{1}{\rho}\nabla p\right) = \nabla\left( \frac{1}{\rho}\right) \times\nabla p + \left( \frac{1}{\rho}\right)\nabla \times\nabla p = \frac{1}{\rho^2}\nabla\rho\times\nabla p.
\end{equation}</p>

<p>The last term is zero. For a flow with constant entropy (incompressible, homentropic), the pressure is solely a function of density, this means that the two vector $\nabla\rho$ and $\nabla p$ are aligned and the fist term equaly vanishes. (More precisely, the baroclinic term which account for the change in the vorticity field due to the interaction of density and pressure surfaces <a href="#Bailly">(Bailly et <em>al.</em>)</a> vanishes). The vorticity equation is therefore given by</p>

<p>\begin{equation}
	\frac{\partial\boldsymbol{\omega}}{\partial t} + \boldsymbol{u}\cdot\nabla\boldsymbol{\omega} = \boldsymbol{\omega}\cdot\nabla\boldsymbol{u} + \nu \nabla^2 \boldsymbol{\omega}.
\end{equation}</p>

<p>In 2D, these equations can be simplified further by noting that the component of the velocity field are</p>

<p>\begin{equation}
\boldsymbol{u} = (u, v, 0), \quad \frac{\partial}{\partial z} =0.
\end{equation}</p>

<p>The vorticity is, by definition, normal to the $x$-$y$ plane ($\boldsymbol{\omega}=(0, 0, \omega_z)$). This means that the term $\boldsymbol{\omega}\cdot\nabla\boldsymbol{u}$ is zero, as is easily demonstrated</p>

\[\boldsymbol{\omega}\cdot\nabla\boldsymbol{u} = \left(\underbrace{\omega_x}_{0}\frac{\partial}{\partial x} + \underbrace{\omega_y}_{0}\frac{\partial}{\partial y} + \omega_z\underbrace{\frac{\partial}{\partial z}}_{0}\right)\boldsymbol{u}.\]

<p>This term is the so-called vortex-stretching term. It is the mean by which the energy is cascaded from the large scales to the smaller scales following the $k^{-5/3}$ rule. In 2D this means that the angular velocity of a particle is conserved, and the length of a vortex tube cannot change due to continuity <a href="#MIT">, see MIT notes</a>.</p>

<p>In 3D, the vortex-stretching term has the form $\omega_{j}\frac{\partial u_i}{\partial x_j}$, thus looking at, say the second component, we have</p>

<p>\begin{equation}
	\omega_{j}\frac{\partial u_i}{\partial x_j} = \omega_{1}\frac{\partial u_2}{\partial x_1} + \omega_{2}\frac{\partial u_2}{\partial x_2} + \omega_{3}\frac{\partial u_2}{\partial x_3}, 
\end{equation}</p>

<p>the first and the third components can be seen as <em>vortex-turning</em> and the second component is the vortex-stretching.</p>

<p>We also note that because the vorticity field has only one non-zero component, the only equation for the transport of vorticity is given by</p>

<p><a id="1.2"></a>
\begin{equation}
	\frac{\partial\omega}{\partial t} +u\frac{\partial\omega}{\partial x} + v\frac{\partial\omega}{\partial y} =  \frac{1}{Re} \left(\frac{\partial^2\omega}{\partial x^2}+ \frac{\partial^2\omega}{\partial y^2}\right).
\tag{1.2}
\end{equation}</p>

<p>Where $Re$ is the Reynold’s number of the flow.</p>

<h2 id="stream-function">Stream function</h2>

<p>To remove the implicit dependency on the velocity field from the vorticity equation, we introduce a vector-valued stream function $\boldsymbol{\psi}$. We will now show that for 2D flows this is in fact a scalar function. Using the definition of the stream function, we have</p>

<p>\begin{equation}
	\boldsymbol{u} = \nabla\times\boldsymbol{\psi}, \qquad u_i = \varepsilon_{ijk}\frac{\partial \psi_k}{\partial x_j},
\end{equation}</p>

<p>where the only two non-zero components of the velocity field are</p>

<p>\begin{equation}
	 u_1 = \varepsilon_{123}\frac{\partial \psi_3}{\partial x_2}=\frac{\partial \psi_3}{\partial x_2}, \qquad u_2 = \varepsilon_{213}\frac{\partial \psi_3}{\partial x_1}=-\frac{\partial \psi_3}{\partial x_1}.
\end{equation}</p>

<p>With $\varepsilon_{ijk}$, the Levi-Civita permutation symbol. Thus only one component of the stream-function is non-zero, and it can be seen as a scalar field $\psi$, with the following relationship to the velocity field</p>

<p>\begin{equation}
	u = \frac{\partial \psi}{\partial y}, \,\,\,\, v = -\frac{\partial \psi}{\partial x}.
\end{equation}</p>

<p>We can substitute these relation into the vorticity equation <a href="#1.2">(1.2)</a>, giving</p>

<p><a id="1.3"></a>
\begin{equation}
	\frac{\partial\omega}{\partial t} +\frac{\partial \psi}{\partial y}\frac{\partial\omega}{\partial x} - \frac{\partial \psi}{\partial x}\frac{\partial\omega}{\partial y} =  \frac{1}{Re} \left(\frac{\partial^2\omega}{\partial x^2}+ \frac{\partial^2\omega}{\partial y^2}\right).
\tag{1.3}
\end{equation}</p>

<p>A very useful property of the stream function is that is existence guarantees the flow to be solenoidal (satisfies continuity). Indeed, substitution of the definition of the stream function into the continuity equation gives</p>

<p>\begin{equation}
	\nabla\cdot\boldsymbol{u} = \nabla\cdot(\nabla\times\boldsymbol{\psi})\equiv 0.
\end{equation}</p>

<p><a href="#1.3">(1.3)</a> still has 2 unknowns, $\psi$ and $\omega$, fortunately we can build a Poisson equation for the vorticity by substituting the velocity components, in terms of the stream function, in the definition of the only non-zero component of the vorticity</p>

<p>\begin{equation}
	\omega_{i}=\varepsilon_{ijk}\frac{\partial u_k}{\partial x_j} \qquad \rightarrow \qquad \omega =\omega_{z}=\frac{\partial v}{\partial x} - \frac{\partial u}{\partial y}
\end{equation}</p>

<p>giving</p>

<p><a id="1.4"></a>
\begin{eqnarray}
  \omega =-\frac{\partial }{\partial x}\frac{\partial \psi}{\partial x} - \frac{\partial }{\partial y}\frac{\partial \psi}{\partial y} &amp;=&amp; -\frac{\partial^2 \psi}{\partial x^2} - \frac{\partial^2 \psi}{\partial x^2},\nonumber<br />
	-\omega&amp;=&amp;\frac{\partial^2 \psi}{\partial x^2} + \frac{\partial^2 \psi}{\partial x^2}.
    \tag{1.4}
\end{eqnarray}</p>

<p>Equation <a href="#1.3">(1.3)</a> together with <a href="#1.4">(1.4)</a> can be solved to simulate the transport of a vorticity field.</p>

<h2 id="numerical-method">Numerical method</h2>

<h3 id="spectral-collocation-method">Spectral collocation method</h3>

<p>For periodic problems, such as the one of homogeneous isotropic decaying turbulence in a periodic domain, collocation methods using trigonometric polynomial expansions are unmatched in terms of accuracy and precision. However, they tend to be an order of magnitude more expensive (computationally) when compared to high-order finite difference schemes. Fortunately, when using trigonometric basis functions, the use of Fast Fourier Transform (<em>FFT</em>’s) routines allows for a reduction in the computational time. We describe here the implementation of such a method to solve <a href="#1.3">(1.3)</a> and <a href="#1.4">(1.4)</a>.</p>

<p>We define the forward Fourier transform of a discrete field $u$ as (transforming from Fourier to physical space), following <a href="#San">San et <em>al.</em></a></p>

<p><a id="2.1"></a>
\begin{equation}
  u_{i,j} = \sum_{m=-\frac{N_x}{2}}^{\frac{N_x}{2}-1}\sum_{n=-\frac{M_y}{2}}^{\frac{M_y}{2}-1}\tilde{u}_{m,n}e^{\boldsymbol{i}\left( \frac{2\pi m}{L_x} x_i + \frac{2\pi n}{L_y}y_j \right)},
 \tag{2.1}
\end{equation}</p>

<p>with its opposite transform, the backward Fourier transform (transforming from physical to Fourier space)</p>

\[\tilde{u}_{m,n} = \frac{1}{N_x N_y} \sum_{i=0}^{N_x-1} \sum_{j=0}^{N_y-1} u_{i,j} e^{\boldsymbol{-i} \left( \frac{2\pi m}{L_x} x_i + \frac{2\pi n}{L_y}y_j \right)}.\]

<p>We note here that the transforms are normalised, a forward, followed by a backward transform recover the initial discrete field. In this case we have chosen to normalise the backward transform.
The wave numbers are defined as</p>

<p>\begin{equation}
	k_x = \frac{2\pi m}{L_x}, \qquad k_y = \frac{2\pi n}{L_y}.
\end{equation}</p>

<p>The natural ordering of Fourier coefficients is as shown in <a href="#2.1">(2.1)</a>, however, <em>FFT</em> routines organise them in a different way, for a reason of algorithm efficiency</p>

<p>\begin{equation}
	k_x = \left[0, 1, \cdots, \frac{N_x}{2}-1, -\frac{N_x}{2}, \cdots, -2, -1 \right],
\end{equation}</p>

<p>for an even number of grid points.</p>

<p>The $N_x$ discrete collocation (grid) points are uniformly space in our $[L_x, L_y]$ domain as</p>

<p>\begin{equation}
	x_i = \frac{iL_x}{N_x} ,\qquad y_i = \frac{iL_y}{N_y},
\end{equation}</p>

<p>with $i=0, 1, \cdots, N_x/N_y$. Because the problem is periodic, $x_0 = x_{N_x}$, we do not include the last grid point in the simulations, as collocation methods using periodic basis functions automatically impose the periodicity on the problem.</p>

<p>The high precision of the spectral collocation method comes from its ability to threat spatial derivatives. By transforming a discrete physical field to Fourier-space, what would otherwise be done using a differential scheme (truncated to a certain accuracy), derivatives are evaluated by multiplying the Fourier coefficients by the corresponding complex wave number, for example, the $n^{th}$  $x$-derivative of a discrete field $u$ is given by</p>

<p>\begin{equation}
	\frac{\partial^{(n)} u_{i, j}}{\partial x^{(n)}} = \sum_{m=-\frac{N_x}{2}}^{\frac{N_x}{2}-1}\sum_{n=-\frac{M_y}{2}}^{\frac{M_y}{2}-1}\tilde{u}_{m,n}(\boldsymbol{i}k_x)^{(n)}e^{\boldsymbol{i}\left( \frac{2\pi m}{L_x} x_i + \frac{2\pi n}{L_y}y_j \right)},
\end{equation}</p>

<p>this is the power of spectral collocation methods. The only errors associated with this operation are the interpolation and truncation errors \cite{spectral}, which are much smaller than the finite-difference equivalent.</p>

<p>Applying these operators to the vorticity transport equation result in a transport equation for the discrete Fourier coefficients</p>

\[\frac{\partial\tilde{\omega}_{m,n}}{\partial t} + (\boldsymbol{i}k_y\tilde{\psi}_{m,n}\circ\boldsymbol{i}k_x\tilde{\omega}_{m,n}) - (\boldsymbol{i}k_x\tilde{\psi}_{m,n}\circ\boldsymbol{i}k_y\tilde{\omega}_{m,n}) = \frac{1}{Re}\left[\left(-k_x^2 - k_y^2\right)\tilde{\omega}_{m,n}\right]\]

<p>where the $(\cdots\circ\cdots)$ operator represents a convolution sum. Treating of this term in Fourier space involves solving triad interactions, this is very expansive, $O(N^2)$.
In the pseudo-spectral approach, this term is treated in physical space with the help of the convolution theorem, which reduces the cost to $O(45/4N\log_2 (3/2N))$.</p>

<h4 id="aliasing">Aliasing</h4>

<p>To prevent high frequencies modes of being falsly represented on the discrete grid dealiasing is employed. Here we use $3/2$ rule to pad the wave number during the transforms. Instead of using the inverse <em>FFT</em> with $N$ points, we use $M = 3/2N$ points. The new Fourier coefficients are zero-padded <a href="#Canuto">(Canuto et <em>al.</em>)</a>, that is</p>

\[\begin{split}
	\tilde{\omega}_{m, n} &amp;=&amp; \tilde{\omega}_{m, n}, \quad\quad |m|\le N_x, \quad |n|\le N_y,\\
	\tilde{\omega}_{m, n} &amp;=&amp; 0  \quad\quad\quad\quad |m|&gt; N_x, \quad |n|&gt; N_y.
\end{split}\]

<p>Once we have obtained the two terms in the convolution sum in physical space via the backward transform and using $M$ points, we simply proceed to a multiplication. The result is then transformed back in Fourier space using the forward transform, still with $M$ points. We then discard all modes whose wave numbers are greater than $N_x$ and $N_y$. In summary, the convolution sums are treated as</p>

\[(\boldsymbol{i}k_y\tilde{\psi}_{m,n}\circ\boldsymbol{i}k_x\tilde{\omega}_{m,n}) = \left[\mathcal{F}_{M}\left(\mathcal{F}^{-1}_{M}(\boldsymbol{i}k_y\tilde{\psi}_{m,n})\mathcal{F}^{-1}_{M}(\boldsymbol{i}k_x\tilde{\omega}_{m,n})\right)\right]_{N}\,,\]

<p>where \(\mathcal{F}_{M}\) represent a <em>Fast Fourier Transform</em> using $M$ points, but we are ultimately interested only in $N$ of them, and the remaining are discarded.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_add_convection</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="s">"""
    Convective term. To prevent alliasing, we zero-pad the array before
    using the convolution theorem to evaluate it in physical space.
    """</span>
    <span class="c1"># initialize padded arrays
</span>    <span class="n">j1f_padded</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">self</span><span class="p">.</span><span class="n">mx</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">mk</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">'complex128'</span><span class="p">)</span>
    <span class="n">j2f_padded</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">self</span><span class="p">.</span><span class="n">mx</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">mk</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">'complex128'</span><span class="p">)</span>
    <span class="n">j3f_padded</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">self</span><span class="p">.</span><span class="n">mx</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">mk</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">'complex128'</span><span class="p">)</span>
    <span class="n">j4f_padded</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">self</span><span class="p">.</span><span class="n">mx</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">mk</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s">'complex128'</span><span class="p">)</span>

    <span class="c1"># populate
</span>    <span class="n">j1f_padded</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">padder</span><span class="p">,</span> <span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">nk</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0j</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">kx</span><span class="p">[:</span><span class="n">self</span><span class="p">.</span><span class="n">nk</span>     <span class="p">]</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">psih</span><span class="p">[:,:]</span>
    <span class="n">j2f_padded</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">padder</span><span class="p">,</span> <span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">nk</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0j</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">ky</span><span class="p">[:,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">wh</span><span class="p">[:,:]</span>
    <span class="n">j3f_padded</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">padder</span><span class="p">,</span> <span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">nk</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0j</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">ky</span><span class="p">[:,</span> <span class="n">np</span><span class="p">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">psih</span><span class="p">[:,:]</span>
    <span class="n">j4f_padded</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">padder</span><span class="p">,</span> <span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">nk</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0j</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">kx</span><span class="p">[:</span><span class="n">self</span><span class="p">.</span><span class="n">nk</span>     <span class="p">]</span>  <span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">wh</span><span class="p">[:,:]</span>
    
    <span class="c1"># backward transform
</span>    <span class="n">j1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">irfft2</span><span class="p">(</span><span class="n">j1f_padded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">j2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">irfft2</span><span class="p">(</span><span class="n">j2f_padded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">j3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">irfft2</span><span class="p">(</span><span class="n">j3f_padded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">j4</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">irfft2</span><span class="p">(</span><span class="n">j4f_padded</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># forward transform
</span>    <span class="n">jacpf</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="nf">rfft2</span><span class="p">(</span><span class="n">j1</span><span class="o">*</span><span class="n">j2</span> <span class="o">-</span> <span class="n">j3</span><span class="o">*</span><span class="n">j4</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># this term is the result of padding, padder allows for easier sclicing
</span>    <span class="n">self</span><span class="p">.</span><span class="n">dwhdt</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">jacpf</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">padder</span><span class="p">,</span> <span class="p">:</span><span class="n">self</span><span class="p">.</span><span class="n">nk</span><span class="p">]</span><span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">pad</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> 

</code></pre></div></div>

<h4 id="a-note-on-ffts-in-python">A note on FFTs in Python</h4>

<p>These examples use the strandard numpy <em>FFT</em> routines. Those are highly inefficient. A much better FFT library is <a href="https://pypi.org/project/pyFFTW/">pyFFTw</a>, but this increase in speed comes at the cost of more complexity. In brief, arrays that will be transformed must be aligned in memory and this requires modifying their content instead of assigning them new values every time we update their values, which explains the <code class="language-plaintext highlighter-rouge">dwhdt[:,:]</code> part. For an example on how to use pyFFTw see <a href="https://github.com/marinlauber/my-numerical-recipes/blob/master/pyFFTW.ipynb">here</a>.</p>

<h4 id="stream-function-1">Stream-function</h4>

<p>The Fourier coefficients of the stream function are obtained by the explicit relationship between vorticity and stream-function</p>

\[-\tilde{\omega}_{m, n} = (-k_x^2 - k_y^2)\tilde{\psi}_{m,n} \qquad\rightarrow\qquad \tilde{\psi}_{m,n} = \frac{\tilde{\omega}_{m, n}}{(k_x^2 + k_y^2)}.\]

<p>We note here that the mode $\tilde{\psi}_{0,0}$ is the results of a division by zero and represents the mean value of $\psi$. To avoid issues with round-up errors accumulating and poluting the solution, it is explicitly set to zero each computation of the stream-function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_get_psih</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="s">"""
    Spectral stream-function from spectral vorticity
    """</span>
    <span class="c1"># k2I stores inverse of k^2, with zero at [0, 0]
</span>    <span class="n">self</span><span class="p">.</span><span class="n">psih</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">wh</span><span class="p">[:,:]</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">k2I</span><span class="p">[:,:]</span>
</code></pre></div></div>

<h3 id="time-integration">Time integration</h3>

<p>Using spectral operators for the spatial derivatives ensures that the discretisation error of spatial terms is kept to a minimum. In order to keep the global discretisation errors low, high-order temporal integrator are required. We implement both a third and a fourth-order Runge-Kutta method.
The third-order TVD Runge-Kutta method is defined as~<a href="#Spectral">(spectral</a></p>

\[\begin{split}
	\tilde{\omega}^{(1)} &amp;= \tilde{\omega}^{n} + \Delta t \mathcal{L}(\tilde{\omega}^n),\\
	\tilde{\omega}^{(2)} &amp;= \frac{3}{4}\tilde{\omega}^{n} + \frac{1}{4}\tilde{\omega}^{(1)} +\frac{1}{4}\Delta t\mathcal{L}(\tilde{\omega}^{(1)}),\\
	\tilde{\omega}^{n+1} &amp;= \frac{1}{3}\tilde{\omega}^n + \frac{2}{3}\tilde{\omega}^{(2)} + \frac{2}{3}\Delta t\mathcal{L}(\tilde{\omega}^{(2)}),
\end{split}\]

<p>where $\mathcal{L}(\tilde{\omega}_n)$ represents all the spatial operators of the transport equation of the Fourier coefficients. Another scheme of order $s$ (for linear problems) that is also TVD and can be easily implemented is</p>

\[\begin{split}
  \tilde{\omega}^{(1)} &amp;= \tilde{\omega}^{n} + \frac{1}{s}\Delta t \mathcal{L}(\tilde{\omega}^n),\\
  \tilde{\omega}^{(2)} &amp;= \tilde{\omega}^{n} + \frac{1}{s-1}\Delta t \mathcal{L}(\tilde{\omega}^{(1)}),\\
  \cdots &amp;\\
  \tilde{\omega}^{n+1} &amp;= \tilde{\omega}^n + \frac{1}{1}\Delta t\mathcal{L}(\tilde{\omega}^{(s)}).
\end{split}\]

<p>Applying the time integration to the fourier coefficients allows us to save two transform per time-steps.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="s">"""
    Explicit low-storage S-order Runge-Kutta method from
    Jameson, Schmidt and Turkel (1981).
    Input:
        s : float
            - desired order of the method, default is 3rd order
    """</span>
    <span class="c1"># initialise
</span>    <span class="n">self</span><span class="p">.</span><span class="n">w0</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">wh</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        
        <span class="c1"># invert Poisson equation for the stream function
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">_get_psih</span><span class="p">()</span>

        <span class="c1"># get convective forces (resets dwhdt)
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">_add_convection</span><span class="p">()</span>

        <span class="c1"># add diffusion
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">_add_diffusion</span><span class="p">()</span>

        <span class="c1"># step in time
</span>        <span class="n">self</span><span class="p">.</span><span class="n">wh</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">w0</span> <span class="o">+</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dt</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">dwhdt</span>

    <span class="n">self</span><span class="p">.</span><span class="n">time</span> <span class="o">+=</span> <span class="n">self</span><span class="p">.</span><span class="n">dt</span>
    <span class="n">self</span><span class="p">.</span><span class="n">it</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">_cfl_limit</span><span class="p">()</span>
</code></pre></div></div>

<h4 id="adaptive-time-step">Adaptive time-step</h4>

<p>The time-step is adjusted based on the Courrant condition in the worst cell of the domain. For a third-order Runge-Kutta scheme, the maximum CFL number is $\sqrt{3}$. This gives the following time-setp, for stability</p>

<p>\begin{equation}
  \Delta t = \frac{\sqrt{3}}{D_c + D_{\mu}},
\end{equation}</p>

<p>where $D_c$ and $D_{\mu}$ are the convective and diffusive velocity scales</p>

\[\begin{split}
  D_c &amp;= \max\left(\pi\left(\frac{1+\vert u\vert}{\Delta x} +\frac{1+\vert v\vert}{\Delta y} \right)\right),\\
  D_{\mu} &amp;= \max\left(\pi^2\left(\frac{1}{\Delta x^2} + \frac{1}{\Delta y^2}\right)\right).
\end{split}\]

<p>These are derived from the advection-diffusion equation (which is very similar to <a href="#1.3">(1.3)</a>), by writting it as a first order ODE and applying Fourier transform to the original equation. The convective and diffusive time-scales are then obtained by considering the worst case in the domain.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_cfl_limit</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="s">"""
    Adjust time-step based on the courant condition
    """</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">get_u</span><span class="p">()</span>
    <span class="n">self</span><span class="p">.</span><span class="nf">get_v</span><span class="p">()</span>
    <span class="n">Dc</span> <span class="o">=</span>  <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="nf">abs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">u</span><span class="p">))</span> <span class="o">/</span> <span class="n">self</span><span class="p">.</span><span class="n">dx</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="nf">abs</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">v</span><span class="p">))</span> <span class="o">/</span> <span class="n">self</span><span class="p">.</span><span class="n">dy</span><span class="p">))</span>
    <span class="n">Dmu</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dx</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">dy</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">self</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">Dc</span> <span class="o">+</span> <span class="n">Dmu</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="validation">Validation</h2>

<h3 id="taylor-green-vortex">Taylor-Green vortex</h3>

<p>We validate the numerical method described above using the Taylor-Green vortex, a known solution to the Navier-Stokes equation. Expressed in its 2D vorticity formulation, it reads</p>

<p><a id="4.1"></a>
\begin{equation}
	\omega^e(x, y, t) = 2\kappa\cos(\kappa x)\cos(\kappa y)e^{-2\kappa^2t/Re}, \tag{4.1}
\end{equation}</p>

<p>where $\kappa=4$ is the number of vortices in each direction and $Re$ is the Reynolds number of the flow and is set to 1.0 for those simulations (dissipation is important in this flow).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flow</span> <span class="o">=</span> <span class="nc">Fluid</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">Re</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> <span class="c1"># generate a 128x128 grid
</span><span class="n">flow</span><span class="p">.</span><span class="nf">init_solver</span><span class="p">()</span>
<span class="n">flow</span><span class="p">.</span><span class="nf">init_field</span><span class="p">(</span><span class="n">TaylorGreen</span><span class="p">)</span>
<span class="n">finish</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

<span class="c1"># loop to solve
</span><span class="nf">while</span><span class="p">(</span><span class="n">flow</span><span class="p">.</span><span class="n">time</span><span class="o">&lt;=</span><span class="n">finish</span><span class="p">):</span>

    <span class="c1">#  update using RK
</span>    <span class="n">flow</span><span class="p">.</span><span class="nf">update</span><span class="p">()</span>

    <span class="c1">#  print every 100 iterations
</span>    <span class="nf">if </span><span class="p">(</span><span class="n">flow</span><span class="p">.</span><span class="n">it</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Iteration %d, time %f, time remaining %f. TKE: %f, ENS: %f"</span> <span class="o">%</span><span class="p">(</span><span class="n">flow</span><span class="p">.</span><span class="n">it</span><span class="p">,</span>
              <span class="n">flow</span><span class="p">.</span><span class="n">time</span><span class="p">,</span> <span class="n">finish</span><span class="o">-</span><span class="n">flow</span><span class="p">.</span><span class="n">time</span><span class="p">,</span> <span class="n">flow</span><span class="p">.</span><span class="nf">tke</span><span class="p">(),</span> <span class="n">flow</span><span class="p">.</span><span class="nf">enstrophy</span><span class="p">()))</span>

<span class="n">end_time</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Execution time for %d iterations is %f seconds."</span> <span class="o">%</span><span class="p">(</span><span class="n">flow</span><span class="p">.</span><span class="n">it</span><span class="p">,</span> <span class="n">end_time</span><span class="o">-</span><span class="n">start_time</span><span class="p">))</span>
</code></pre></div></div>
<p>and you should get the following results</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Iteration 100, time 0.020564, time remaining 0.079436. TKE: 0.180244, ENS: 23585.873276
Iteration 200, time 0.041258, time remaining 0.058742. TKE: 0.129470, ENS: 16941.804099
Iteration 300, time 0.061970, time remaining 0.038030. TKE: 0.092971, ENS: 12165.670770
Iteration 400, time 0.082698, time remaining 0.017302. TKE: 0.066744, ENS: 8733.753359

Execution time for 484 iterations is 11.454845 seconds.
</code></pre></div></div>

<p>We use the $L_2$-norm of the error between the exact solution and the simulation to quantify the error</p>

\[L_2 = \sqrt{\frac{1}{N_xN_y}\sum_{i=1}^{N_x} \sum_{j=1}^{N_y}|\omega^{e}_{i, j} - \omega_{i, j}|^2},\]

<p>and the $L_\infty$-norm</p>

\[L\infty = \max{\vert \omega^{e}_{i, j} - \omega_{i, j} \vert}.\]

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># get final results
</span><span class="n">flow</span><span class="p">.</span><span class="nf">wh_to_w</span><span class="p">()</span>
<span class="n">w_n</span> <span class="o">=</span> <span class="n">flow</span><span class="p">.</span><span class="n">w</span>

<span class="c1"># exact solution
</span><span class="n">w_e</span> <span class="o">=</span> <span class="nc">TaylorGreen</span><span class="p">(</span><span class="n">flow</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">flow</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">Re</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">flow</span><span class="p">.</span><span class="n">time</span><span class="p">))</span>

<span class="c1"># error norms
</span><span class="nf">print</span><span class="p">(</span><span class="s">"L2-norm   of the error in the Taylor-Green vortex on a %dx%d grid is %e."</span> <span class="o">%</span> <span class="p">(</span><span class="n">flow</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">flow</span><span class="p">.</span><span class="n">ny</span><span class="p">,</span> <span class="nc">L2</span><span class="p">(</span><span class="n">w_e</span> <span class="o">-</span> <span class="n">w_n</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Linf-norm of the error in the Taylor-Green vortex on a %dx%d grid is %e."</span> <span class="o">%</span> <span class="p">(</span><span class="n">flow</span><span class="p">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">flow</span><span class="p">.</span><span class="n">ny</span><span class="p">,</span> <span class="nc">Linf</span><span class="p">(</span><span class="n">w_e</span> <span class="o">-</span> <span class="n">w_n</span><span class="p">)))</span>
</code></pre></div></div>

<p>This is pretty good!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L2-norm   of the error in the Taylor-Green vortex on a 128x128 grid is 4.829892e-13.
Linf-norm of the error in the Taylor-Green vortex on a 128x128 grid is 9.661161e-13..
</code></pre></div></div>

<h3 id="decaying-turbulence">Decaying Turbulence</h3>

<p>We can also generate a random vorticity field, following <a href="#MW">J. C. McWilliams</a> whose initial conditions are a Gaussian random realization for each Fourier component $\tilde{\psi}$</p>

\[\tilde{\psi}_{ij} \leftarrow \mathcal{N}(\mu, \sigma^2),\]

<p>where at each vector wavenumber the ensemble variance is proportional to the scalar wavenumber function</p>

\[\vert\psi\vert^2 = \kappa^{-1}\left[1 + \left(\frac{\kappa}{\kappa_0}\right)^4\right]^{-1},\]

<p>where $\kappa$ is the wavenumber magnitude. This spectrum is broad banded and peaks around $\kappa_0$ (set to $\kappa_0 = 6$ in the following). An aplitude factor is chosen such that the kinetic energy <a href="#4.2">(4.2)</a> is equal to 0.5 initially.</p>

<p>This field can simply be generated by passing the <code class="language-plaintext highlighter-rouge">"McWilliams"</code> function to the flow field initialization function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flow</span> <span class="o">=</span> <span class="nc">Fluid</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">Re</span><span class="o">=</span><span class="mf">100.</span><span class="p">)</span>
<span class="n">flow</span><span class="p">.</span><span class="nf">init_solver</span><span class="p">()</span>
<span class="n">flow</span><span class="p">.</span><span class="nf">init_field</span><span class="p">(</span><span class="n">McWilliams</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="energy-spectrum">Energy Spectrum</h3>

<p>For homogeneous turbulence, we can define the energy spectrum to be a function of the stream-function</p>

<p><a id="4.2"></a>
\begin{equation}
	E(k, t) = \sum_{k-\Delta k \le |\boldsymbol{ k}| \le k+\Delta k} \frac{1}{2} k^2 |\tilde{\psi}(\boldsymbol{ k}, t) |^2, \tag{4.2}
\end{equation}</p>

<p>where $\tilde{\psi}$ is readily obtained from the known vorticity field $\tilde{\omega}$. Each contribution to the final energy spectrum consist of the sum of all the energy contribution at each wavenumber falling within a prescribed bin size, or spectral band, $\Delta k$. The default number of bin used is 200, and the spectral band is defined as the Nyquist frequency devided by the number of bins.</p>

<h3 id="results">Results</h3>

<!-- <iframe width="560" height="315" src="https://www.youtube.com/embed/TJrBldYK88Q" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> -->
<!-- <video autoplay="autoplay" loop="loop" width="800" height="450" codecs="h264" controls>
  <source src="/assets/images/2D_Turbulence/out.mp4" type="video/mp4">
</video> -->
<video autoplay="autoplay" loop="loop" width="800" height="450" codecs="h264" controls="">
  <!-- <source src="/assets/images/2D_Turbulence/output.mp4" type="video/mp4"> -->
  <source src="/assets/images/2D_Turbulence/comp_2560x1440_final.mp4" type="video/mp4" />
</video>

<h3 id="references">References</h3>

<p>[1]<a id="Bailly"></a> C. Bailly, G. Comte-Bellot. <em>Turbulence</em>. Springer Series in: Experimental Fluid Mechanics. 2015.</p>

<p>[2]<a id="MIT"></a> MIT. <a href="https://ocw.mit.edu/courses/mechanical-engineering/2-20-marine-hydrodynamics-13-021-spring-2005/lecture-notes/"><em>Marine Hydrodynamics Lecture 9</em></a>. MIT Marine Hydrodynamics lectures notes. 2005.</p>

<p>[3]<a id="San"></a> O. San, A. E. Staples. <a href="https://www.sciencedirect.com/science/article/abs/pii/S0045793012001363"><em>High-order methods for decaying two-dimensional homogeneous isotropic turbulence</em></a>. Computer &amp; Fluids 63. p: 105–127. 2012.</p>

<p>[4]<a id="Canuto"></a> C. Canuto, M. Y. Hussaini, A.Quarteroni, T. A. Zang. <em>Spectral Methods in Fluid Dynamics</em>. Springer Series in: Computational Physics. 1988.</p>

<p>[4]<a id="MW"></a> J. C. McWilliams. <a href="https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/emergence-of-isolated-coherent-vortices-in-turbulent-flow/3EB789299B1A730265A5EC522E35B630"><em>The emergence of isolated coherent vortices in turbulent flow</em></a>. Journal of fluid mechanics 146. p: 21–43. 1984.</p>

<hr />]]></content><author><name>Marin Lauber</name><email>M.Lauber@tudelft.nl</email></author><summary type="html"><![CDATA[Accurate simulation of 2D Turbulence]]></summary></entry><entry><title type="html">My First Post</title><link href="http://localhost:4000/HelloWorld/" rel="alternate" type="text/html" title="My First Post" /><published>2020-10-03T00:00:00+02:00</published><updated>2020-10-03T00:00:00+02:00</updated><id>http://localhost:4000/HelloWorld</id><content type="html" xml:base="http://localhost:4000/HelloWorld/"><![CDATA[<p>Trying all that <code class="language-plaintext highlighter-rouge">markdown</code>  has to offers</p>

<p><strong>Code Snippets</strong></p>

<p>Print <code class="language-plaintext highlighter-rouge">Hello, World!</code> using <code class="language-plaintext highlighter-rouge">python</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="s">"Hello, World!"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Equations</strong></p>

<p>The <em>Navier-Stokes Equations</em></p>

\[\begin{split}
   &amp;\frac{\partial \vec{u}}{\partial t} + \left(\vec{u}\cdot\nabla\right)\vec{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\vec{u} + \vec{f},\\
   &amp;\nabla\cdot\vec{u} = 0.
\end{split}\]

<p>Where $\vec{u}$ is the velocity field and $p$ is the pressure field.</p>]]></content><author><name>Marin Lauber</name><email>M.Lauber@tudelft.nl</email></author><summary type="html"><![CDATA[Trying all that markdown has to offers]]></summary></entry></feed>